<h1 align = "center">操作系统实验报告</h1>

<h3 align = "center">实验名称：Lab0.5从机器启动到操作系统运行的过程 & Lab1中断与中断处理流程   </h3>

<h4 align = "center">      小组成员：李娅琦 周末 周思洁</h4>

# lab 0.5

## 实验要求
- 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
- 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

## 实验目的
实验0.5主要讲解最小可执行内核和启动流程。我们的内核主要在 Qemu 模拟器上运行，它可以模拟一台 64 位 RISC-V 计算机。为了让我们的内核能够正确对接到 Qemu 模拟器上，需要了解 Qemu 模拟器的启动流程，还需要一些程序内存布局和编译流程（特别是链接）相关知识。

## 实验内容：使用GDB验证启动流程

操作系统作为一个程序，必须加载到内存里才能执行。但是操作系统无法自己做到。因此在操作系统执行之前，会通过bootloader执行，完成“把操作系统加载到内存“这个工作，然后把CPU的控制权交给操作系统。

### 1. 启动OpenSBI

在lab0目录下同时打开终端运行make deb代码ug和make gdb，开始调试ucore

在gdb中运行命令`x/10i $pc`，目的是查看0x1000处的10条汇编指令

```bash
0x0000000000001000 in ?? ()
(gdb) x/10i $pc
=> 0x1000:	auipc	t0,0x0
   0x1004:	addi	a1,t0,32
   0x1008:	csrr	a0,mhartid
   0x100c:	ld	t0,24(t0)
   0x1010:	jr	t0
   0x1014:	unimp
   0x1016:	unimp
   0x1018:	unimp
   0x101a:	0x8000
   0x101c:	unimp
```
这里是QEMU模拟的这款riscv处理器的复位地址`0x1000`，所谓复位地址，指的是CPU在上电的时候，或者按下复位键的时候，PC被赋的初始值。该代码段用于在 RISC-V 架构中进行程序控制和加载，以及启动 `Bootloader`，例如设置寄存器的值、跳转到指定地址以及处理特殊情况。

### 2. 加载bootloader和os内核

接着程序会执行跳转指令到`0x8000`处，这里是用于加载`bootloader` 的 `OpenSBI.bin`和内核镜像`os.bin`的地方。我们进入`0x8000`指令处查看代码。运行指`si 0x0000000080000000 in ?? ()`

```bash

(gdb) x/10i $pc
=> 0x80000000:	csrr	a6,mhartid
   0x80000004:	bgtz	a6,0x80000108
   0x80000008:	auipc	t0,0x0
   0x8000000c:	addi	t0,t0,1032
   0x80000010:	auipc	t1,0x0
   0x80000014:	addi	t1,t1,-16
   0x80000018:	sd	t1,0(t0)
   0x8000001c:	auipc	t0,0x0
   0x80000020:	addi	t0,t0,1020
   0x80000024:	ld	t0,0(t0)
```

这些指令包括加载启动代码的地址、设置寄存器、获取处理器信息等，在 QEMU 开始执行任何指令之前，会首先加载两个文件到物理内存中： `Bootloader` 的 `OpenSBI.bin` 被加载到以物理地址 `0x80000000` 开头的区域，而内核镜像 `os.bin` 则被加载到以物理地址 `0x80200000` 开头的区域。

### 3. 开始执行内核

现在我们进入到加载内核镜像的代码位置`0x80200000`处，通过`break *0x80200000`: 在 `0x80200000` 处设置断点，然后再次运行程序，查看相应代码
```bash
=> 0x80200000 <kern_entry>:		auipc	sp,0x3
   0x80200004 <kern_entry+4>:	mv	sp,sp
   0x80200008 <kern_entry+8>:	j	0x8020000c <kern_init>
   0x8020000c <kern_init>:		auipc	a0,0x3
   0x80200010 <kern_init+4>:	addi	a0,a0,-4
   0x80200014 <kern_init+8>:	auipc	a2,0x3
   0x80200018 <kern_init+12>:	addi	a2,a2,-12
   0x8020001c <kern_init+16>:	addi	sp,sp,-16
   0x8020001e <kern_init+18>:	li	a1,0
   0x80200020 <kern_init+20>:	sub	a2,a2,a0
```

可以看到指令从`kern_entry`运行后跳转到`0x8020000c`，也就是`kern_init`函数部分，这段内容便是内核的初始化了。这里已经是内核开始执行的部分了，已经不属于加电后的执行段，通常用于初始化寄存器、栈帧以及准备参数以调用其他函数。一旦 CPU 开始执行内核的第一条指令，证明计算机的控制权已经被移交给我们的内核。

## 实验中的知识点

**1. 程序内存布局与链接脚本**

程序的内存布局通常在链接脚本中定义。链接脚本指定了代码、数据、堆栈等不同节（sections）在内存中的放置位置。链接器的作用是把输入文件(.o文件)链接成输出文件(elf文件)。一般来说，输入文件和输出文件都有很多section, 链接脚本(linker script)的作用。

**2. 内核栈**

- 内核栈（Kernel Stack）是操作系统内核用于临时存储数据的内存区域。每当一个中断、异常或者系统调用发生时，操作系统内核需要栈来保存当前的执行状态，以便恢复执行。内核栈的管理通常由操作系统内核负责，包括：栈溢出保护,栈空间分配,回收利用。

- 在RISC-V架构中，当一个中断或异常发生时，处理器会自动将PC,状态寄存器,寄存器（如ra, sp, gp, tp等）推入内核栈中。

**3. 固件**

- 固件通常指的是计算机系统中的软件，它存储在ROM或其他非易失性存储设备中，并在系统启动时最先运行。固件的主要任务是初始化硬件设备、建立操作系统所需的运行环境，并把控制权交给操作系统。OpenSBI（Open Source Berkeley Bootloader Interface）是RISC-V架构下的开源固件，它提供了一种标准化的方式来引导操作系统。

- **OpenSBI的启动流程**如下：
系统加电：当系统加电或复位时，硬件会开始执行预设在ROM中的启动代码。
第一阶段引导加载程序（SPL）：如果存在，SPL会进行一些基础的硬件初始化，然后将更完整的引导加载程序（如OpenSBI）加载到内存中。
OpenSBI启动：OpenSBI开始执行，进行更深入的硬件初始化，包括设置内存、中断控制器、计时器等。
操作系统引导：OpenSBI加载操作系统内核，并将其启动。在RISC-V中，这通常涉及到将内核映像和设备树（Device Tree）加载到内存中。
跳转到操作系统：OpenSBI将控制权交给操作系统的入口点，通常是内核的启动例程。

- **OpenSBI的服务**
OpenSBI提供了一系列的SBI调用，操作系统可以通过这些调用来执行诸如打印字符串到控制台、设置定时器、发送IPI等操作。通过ecall指令来调用的。

**4.地址相关代码与地址无关代码**

- 地址相关代码（Address-Dependent Code）和地址无关代码（Address-Independent Code）是两种不同的代码生成方式，它们处理内存地址的方式不同。

- **地址相关代码**
- 地址相关代码（PDC）是指代码中直接包含内存地址的指令。在编译时生成其中的地址是固定的，不能动态变化。例如：
```c
void func(void) {
    char *ptr = (char *)0x1000; // 具体的物理地址
    // ...
}
```
在这段代码中，指针`ptr`被硬编码为一个固定的地址`0x1000`。由于依赖于特定的内存布局，因此不同的执行环境中可能无法正常工作。

- **地址无关代码**
- 地址无关代码（PIC）是指不依赖于特定内存地址的代码。在执行时可以被加载到内存的任何位置并且正常运行。地址无关代码通常用于动态链接库和共享库。其中主要有**使用相对地址**,**重定位**的特点。例如，以下是一个简单的地址无关代码片段：

```c
void func(void) {
    static int var;
    int *ptr = &var; // 相对地址，ptr相对于当前函数的栈帧
    // ...
}
```

在这段代码中，`ptr`指向函数内的静态变量`var`，这是一个相对地址，因为它相对于`func`的栈帧。

- **生成地址无关代码**
编译器通常提供了生成地址无关代码的选项。在GCC中，可以使用`-fPIC`选项来生成地址无关代码。

- **地址无关代码的重要性**
地址无关代码对于开发动态链接库、共享库和操作系统级软件非常重要，因为它们需要在不同的内存地址下运行。此外，地址无关代码也有助于提高代码的安全性，因为它可以减少一些基于地址的攻击（如缓冲区溢出攻击）的可能性。在嵌入式系统和操作系统内核开发中，地址无关代码也是一个关键特性，因为这些系统通常需要在不同的内存布局下运行，以适应不同的硬件配置和内存管理策略。


# lab 1
## 实验要求
- 基于markdown格式来完成，以文本方式为主
- 填写各个基本练习中要求完成的报告内容
- 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
- 列出你认为OS原理中很重要，但在实验中没有对应上的知识点
## 实验目的 
实验1主要讲解的是中断处理机制。操作系统是计算机系统的监管者，必须能对计算机系统状态的突发变化做出反应，这些系统状态可能是程序执行出现异常，或者是突发的外设请求。当计算机系统遇到突发情况时，不得不停止当前的正常工作，应急响应一下，这是需要操作系统来接管，并跳转到对应处理函数进行处理，处理结束后再回到原来的地方继续执行指令。这个过程就是中断处理过程。
## 实验过程

### 练习1
##### 阅读`kern/init/entry.S`内容代码，结合操作系统内核启动流程，说明指令 `la sp, bootstacktop` 完成了什么操作，目的是什么？ `tail kern_init` 完成了什么操作，目的是什么？

`entry.S`文件中的汇编指令负责在OpenSBI启动阶段初始化内核栈，并跳转到内核的初始化函数。以下是这两条指令的解析：

1. `la sp, bootstacktop`：这条指令将bootstacktop标签所指向的内存地址赋值给栈指针寄存器sp，以此初始化引导阶段的栈。这个标签标记了引导栈的顶部位置，为引导程序的基本操作提供了一个栈空间。
2. `tail kern_init`：此指令实现了对kern_init函数的尾调用，使得程序直接跳转到内核初始化函数执行，而不再返回到调用点。这种调用方式有效地将控制权转交给kern_init，开始执行内核的初始化序列。
   
### 练习2
 ##### 请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机。


 我们实现时钟中断的处理函数代码如下：


```C
       case IRQ_S_TIMER:
            // "All bits besides SSIP and USIP in the sip register are
            // read-only." -- privileged spec1.9.1, 4.1.4, p59
            // In fact, Call sbi_set_timer will clear STIP, or you can clear it
            // directly.
            // cprintf("Supervisor timer interrupt\n");
             /* LAB1 EXERCISE2   2211349 :  */
            /*(1)设置下次时钟中断- clock_set_next_event()
             *(2)计数器（ticks）加一
             *(3)当计数器加到100的时候，我们会输出一个`100ticks`表示我们触发了100次时钟中断，同时打印次数（num）加一
            * (4)判断打印次数，当打印次数为10时，调用<sbi.h>中的关机函数关机
            */
            clock_set_next_event();
            if(++ticks%TICK_NUM == 0){
            	print_ticks();
            	num++;
            	if(num == 10){
            	   sbi_shutdown();
            	}
            }
            break;
```
其中`clock_set_next_event()`、`print_ticks()`、` sbi_shutdown()`函数均已给出，只需要在适当的位置进行调用即可。剩下的代码部分只需按照提示给出编写即可。

代码修改后通过：
```bash
make qemu
```
运行后得到的结果如下：
<img src="img/lab1.png" alt="lab1" width="400" height="400"/>

为了测试代码的正确性，我们通过
```bash
make grade
```
得到如下结果:
<img src="img/lab1.1.png" alt="lab1" />
从而验证我们修改的代码的正确性。

### 扩展练习1 
##### 描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。
   
   `mov a0，sp`该指令的作用是将保存上下文后的栈顶指针值赋给a0寄存器，而a0寄存器用作参数寄存器。通过这种方式，当前的中断帧被设置为参数，传递给中断处理程序，以便对中断进行相应的处理。
   
   在保存上下文的过程中，是通过栈顶寄存器sp来索引各个寄存器保存的位置。首先，使用指令`addi sp, sp, -36 * REGBYTES`来调整sp的值，从而在栈上预留出足够的空间，这个空间用于存储上下文中的寄存器值。其中，REGBYTES通常是一个宏，表示单个寄存器的大小，而36则表示需要为多少个寄存器预留空间。完成空间预留后，就可以通过操作sp指针，将各个寄存器的值存储到这个新开辟的栈区域中。

   保存上下文的目的是为了确保中断处理程序能够正确执行。然而，并非所有中断场景都要求保存所有寄存器。中断处理程序的需求和设计决定了哪些寄存器需要被保存。在某些情况下，处理程序可能只涉及少量寄存器，因此只需保存这些相关的寄存器。如果对每个中断都无差别地保存所有寄存器，这将不必要地降低系统的性能和效率。另外，有些寄存器的值在中断期间不会改变，对于这些寄存器，保存它们是不必要的，这样可以减少程序的存储和时间成本。
### 扩展练习2

##### 在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么？save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？

- `csrw sscratch, sp`：这条指令将栈顶指针（sp）的值写入到sscratch这个CSR中。sscratch通常用于在用户模式和监督模式之间切换时保存和恢复上下文，特别是在中断处理中。
- `csrrw s0, sscratch, x0`：这条指令读取sscratch的值并将其放入寄存器s0中，同时将x0（即0）写入sscratch。这样，s0现在包含了原始的栈顶指针值，而sscratch被清零。
  
这两个操作的目的通常是为了在进入中断处理程序时，保存当前线程的栈指针，并在中断处理完成后能够恢复它。这样，中断处理程序可以使用自己的栈，而不会干扰或破坏被中断的线程的栈。

关于save all和restore all：

- `save all`通常是一个宏或汇编代码块，用于在中断发生时保存所有的寄存器，包括CSR。保存stval（存储中断值）和scause（存储中断原因）这些CSR的目的是为了在中断处理程序中可以检查和处理中断的具体原因。
- `restore all`是在中断处理完成后执行的代码块，用于恢复之前保存的寄存器状态，以便继续执行被中断的线程。在`restore all`中通常不会还原stval和scause，因为这些CSR是特定于中断的，它们的值只在处理当前中断时有用。一旦中断处理完成，这些CSR的值就不再需要了，因为它们不会影响线程的正常执行。

### 扩展练习3   

 ##### 编程完善在触发一条非法指令异常 mret和，在 kern/trap/trap.c的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址，即“Illegal instruction caught at 0x(地址)”，“ebreak caught at 0x（地址）”与“Exception type:Illegal instruction"，“Exception type: breakpoint”。

补充的代码内容如下：
```c
case CAUSE_ILLEGAL_INSTRUCTION:
             // 非法指令异常处理
             /* LAB1 CHALLENGE3   2212126 :  */
            /*(1)输出指令异常类型（ Illegal instruction）
             *(2)输出异常指令地址
             *(3)更新 tf->epc寄存器
            */
            cprintf("Exception type:Illegal instruction ");
            cprintf("Illegal instruction at  0x%016llx\n", tf->epc);
            tf->epc+=4;
            break;
        case CAUSE_BREAKPOINT:
            //断点异常处理
            /* LAB1 CHALLLENGE3   2213603 :  */
            /*(1)输出指令异常类型（ breakpoint）
             *(2)输出异常指令地址
             *(3)更新 tf->epc寄存器
            */
            cprintf("Exception type: Breakpoint\n");
            cprintf("Exception address: 0x%08x\n", tf->epc);
            tf->epc += 2;
            break;
```
- 对于非法指令异常（`CAUSE_ILLEGAL_INSTRUCTION`），通常是因为执行了一个未定义或非法的指令。在这种情况下，应该将tf->epc的值增加4，以跳过这条非法指令，然后继续执行后续的指令。
- 对于断点异常（`CAUSE_BREAKPOINT`），它是由执行ebreak指令触发的。ebreak指令是一条被压缩的2字节指令，因此在异常处理结束后，同样应该将tf->epc的值增加4，以跳过这条ebreak指令。
- 
 通过指导手册中的指令添加代码进行测试后，测试结果如下：
<img src="img/lab1.2.png" alt="lab1" />

可以看出正确的输出了异常类型，以及引发异常的地址。
## 实验中的知识点
**1. 中断的类型**

中断处理是一个重要的特性，它允许处理器在执行程序的过程中响应外部事件。RISC-V支持三种中断来源：软件中断、时钟中断（通常由计时器触发）和外部中断。

**2. 中断和异常**

中断和异常都是处理器响应突发事件的机制，但它们触发的原因、处理方式和优先级有所不同

- **中断**是由处理器外部的事件触发的，如硬件设备或外部信号，
- **异常**用于处理内部错误和系统调用，例如非法指令、访问违规、算术溢出等

在RISC-V中，中断和异常都通过陷阱（trap）进行处理

**3. 中断前后的上下文切换**

- 中断前的上下文保存：PC保存到特定的寄存器中-->活动的寄存器保存到堆栈区域-->更新PC为中断处理程序的入口地址-->保存状态寄存器

- 中断处理程序执行:进入中断处理代码-->按照中断类型处理并更新结构体epc的值进行上下文切换

- 中断后的上下文恢复：恢复PC,寄存器状态,状态标志-->返回触发中断的下一条指令继续执行

**4. 断点中断与时钟中断**

- **断点中断**：通常由调试器触发用于调试。当断点中断发生时，处理器会保存当前状态，并跳转到断点处理程序。
- **时钟中断**：由计时器周期性触发。在RISC-V中，时钟中断可以通过设置CLINT的mtimecmp寄存器来管理。当中钟中断发生时，处理器会保存当前状态，更新mtimecmp寄存器值以计划下一个中断，然后跳转到时钟中断处理程序。